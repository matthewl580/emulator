<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ChipCode - API Documentation</title>
    <link rel="stylesheet" href="../styles.css">
    <script>
        // Theme handling
        const getPreferredTheme = () => {
            const saved = localStorage.getItem('theme');
            if (saved) return saved;
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        };

        const applyTheme = (theme) => {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        };

        applyTheme(getPreferredTheme());

        const toggleTheme = () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            applyTheme(next);
        };
    </script>
</head>
<body class="ide-body">
    <button onclick="toggleTheme()" class="theme-toggle">
        Toggle Theme
    </button>

    <nav class="nav">
        <div class="nav-inner">
            <a class="nav-brand" href="../index.html">ChipCode</a>
            <div class="nav-links">
                <a href="../editor/">Editor</a>
                <a href="../game/">Play</a>
                <a href="../docs/">Docs</a>
            </div>
        </div>
    </nav>

    <main class="home-main">
        <h1>API Documentation</h1>

        <section>
            <h2>Language Overview</h2>
            <p>ChipCode uses a subset of JavaScript with additional built-in objects and methods specifically designed for game development. The language is designed to be simple yet powerful enough for creating complex games.</p>

            <h3>Key Features</h3>
            <ul>
                <li>Full JavaScript ES5 compatibility</li>
                <li>Built-in game-specific objects and methods</li>
                <li>Automatic variable scoping</li>
                <li>Direct canvas manipulation</li>
                <li>Audio synthesis integration</li>
            </ul>
        </section>

        <section>
            <h2>Game Structure</h2>
            <p>Games in ChipCode are defined by two main functions and configuration properties:</p>
            <pre class="code-editor">
{
    "initCode": "// Setup code here",
    "updateCode": "// Per-frame update code here",
    "displayMode": "1",  // Display mode (1: standard, 2: high-res, 3: debug)
    "timestamp": "ISO date string"
}</pre>
            
            <h3>Property Details</h3>
            <ul>
                <li><code>initCode</code>: Initialization code that runs once when the game starts</li>
                <li><code>updateCode</code>: Game loop code that runs every frame (60 FPS)</li>
                <li><code>displayMode</code>:
                    <ul>
                        <li>"1": Standard mode (64x64 scaled)</li>
                        <li>"2": High resolution mode (128x128 scaled)</li>
                        <li>"3": Debug mode (shows FPS and memory usage)</li>
                    </ul>
                </li>
                <li><code>timestamp</code>: Last modification time in ISO format</li>
            </ul>
        </section>

        <section>
            <h2>Game Canvas</h2>
            <p>The game canvas has a logical resolution of 64x64 pixels and is automatically scaled to fit the display.</p>
            <h3>Canvas Methods</h3>
            <pre class="code-editor">
// Get the canvas context
const ctx = document.getElementById('game-canvas').getContext('2d');

// Clear the screen
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Draw a pixel (scaled automatically)
const scale = canvas.width / 64;
ctx.fillRect(x * scale, y * scale, scale, scale);

// Draw text
ctx.fillStyle = '#ffffff';
ctx.font = '12px monospace';
ctx.fillText('Hello World', x, y);</pre>
        </section>

        <section>
            <h2>Built-in Objects</h2>
            
            <h3>Game State (<code>window._state</code>)</h3>
            <p>The global state object for storing game data:</p>
            <pre class="code-editor">
window._state = {
    // Game state management
    player: { x: 0, y: 0, score: 0 },
    entities: [],
    gameOver: false
};</pre>

            <h3>Input System (<code>window._input</code>)</h3>
            <p>Input state management for keyboard, mouse, and touch:</p>
            <pre class="code-editor">
// Keyboard state
window._input.keys = {
    ArrowLeft: false,
    ArrowRight: false,
    // ... other keys
};

// Mouse position and state
window._input.mouse = {
    x: 0,        // Logical x coordinate (0-63)
    y: 0,        // Logical y coordinate (0-63)
    pressed: false,
    button: 0    // 0: left, 1: middle, 2: right
};

// Touch input array
window._input.touches = [
    { id: 1, x: 0, y: 0 },
    // ... other touch points
];</pre>

            <h3>Graphics Engine (<code>window._graphics</code>)</h3>
            <p>Advanced rendering functions:</p>
            <pre class="code-editor">
// Sprite management
window._graphics.sprites = {
    load: (id, url) => Promise,
    draw: (id, x, y, options) => void
};

// Special effects
window._graphics.effects = {
    shake: (intensity, duration) => void,
    flash: (color, duration) => void,
    fade: (type, duration) => void
};</pre>

            <h2>Audio System</h2>
            <p>ChipCode uses an advanced audio system based on Tone.js for synthesis and playback.</p>
            
            <h3>Basic Synthesis</h3>
            <pre class="code-editor">
// Create synthesizers
const synth = new Tone.Synth().toDestination();
const poly = new Tone.PolySynth().toDestination();
const drum = new Tone.MembraneSynth().toDestination();

// Play individual notes
synth.triggerAttackRelease("C4", "8n");
poly.triggerAttackRelease(["C4", "E4", "G4"], "4n");
drum.triggerAttackRelease("C2", "8n");

// Create musical patterns
const melody = new Tone.Sequence((time, note) => {
    synth.triggerAttackRelease(note, "8n", time);
}, ["C4", "D4", "E4", "G4"]).start(0);

// Complex musical loops
const loop = new Tone.Loop((time) => {
    // Melody
    synth.triggerAttackRelease("C4", "8n", time);
    synth.triggerAttackRelease("E4", "8n", time + 0.25);
    // Bass
    drum.triggerAttackRelease("C2", "4n", time);
}, "2n").start(0);

// Audio transport control
// Set tempo
Tone.Transport.bpm.value = 120;</pre>
            
            <h3>Additional Audio Features</h3>
            <p>For more advanced audio features, see the complete <a href="https://tonejs.github.io/" target="_blank" rel="noopener">Tone.js documentation</a>.</p>
        </section>

        <section>
            <h2>Utility Methods</h2>

            <h3>Math Utilities</h3>
            <p>Essential mathematical functions for game development:</p>
            <pre class="code-editor">
// Random number generation
window.random = (min, max) => 
    Math.floor(Math.random() * (max - min + 1)) + min;

// Value clamping
window.clamp = (value, min, max) => 
    Math.min(Math.max(value, min), max);

// Linear interpolation
window.lerp = (start, end, t) => 
    start + (end - start) * t;

// Distance calculation
window.distance = (x1, y1, x2, y2) => 
    Math.sqrt((x2-x1)**2 + (y2-y1)**2);

// Angle between points (in radians)
window.angle = (x1, y1, x2, y2) => 
    Math.atan2(y2 - y1, x2 - x1);</pre>

            <h3>Collision Detection</h3>
            <p>Comprehensive collision detection functions:</p>
            <pre class="code-editor">
// Point vs Rectangle
window.pointInRect = (px, py, rx, ry, rw, rh) => 
    px >= rx && px < rx + rw && 
    py >= ry && py < ry + rh;

// Rectangle vs Rectangle
window.rectIntersect = (r1x, r1y, r1w, r1h, 
                       r2x, r2y, r2w, r2h) => 
    r1x < r2x + r2w && r1x + r1w > r2x &&
    r1y < r2y + r2h && r1y + r1h > r2y;

// Circle vs Circle
window.circleIntersect = (c1x, c1y, c1r, 
                         c2x, c2y, c2r) => 
    distance(c1x, c1y, c2x, c2y) < c1r + c2r;

// Point vs Circle
window.pointInCircle = (px, py, cx, cy, cr) =>
    distance(px, py, cx, cy) < cr;</pre>

            <h3>Vector Operations</h3>
            <p>2D vector manipulation utilities:</p>
            <pre class="code-editor">
// Create a vector
window.vector = (x, y) => ({ x, y });

// Add vectors
window.vectorAdd = (v1, v2) => 
    vector(v1.x + v2.x, v1.y + v2.y);

// Scale vector
window.vectorScale = (v, scale) => 
    vector(v.x * scale, v.y * scale);

// Vector magnitude
window.vectorMagnitude = (v) => 
    Math.sqrt(v.x * v.x + v.y * v.y);

// Normalize vector
window.vectorNormalize = (v) => {
    const mag = vectorMagnitude(v);
    return mag === 0 ? v : vectorScale(v, 1/mag);
};</pre>

            <h3>Color Manipulation</h3>
            <p>Color conversion and interpolation functions:</p>
            <pre class="code-editor">
// RGB to Hex
window.rgbToHex = (r, g, b) => 
    '#' + [r, g, b]
        .map(x => Math.floor(x)
        .toString(16)
        .padStart(2, '0'))
        .join('');

// Hex to RGB
window.hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

// Lerp between colors
window.lerpColor = (color1, color2, t) => {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    return rgbToHex(
        lerp(c1.r, c2.r, t),
        lerp(c1.g, c2.g, t),
        lerp(c1.b, c2.b, t)
    );
};</pre>

            <h3>Data Structures</h3>
            <p>Essential data structures for game development:</p>
            <pre class="code-editor">
// Grid creation
window.createGrid = (width, height, defaultValue = 0) =>
    Array(height).fill().map(() => 
        Array(width).fill(defaultValue));

// Queue implementation
window.Queue = class {
    constructor() {
        this.items = [];
    }
    enqueue(item) { this.items.push(item); }
    dequeue() { return this.items.shift(); }
    peek() { return this.items[0]; }
    isEmpty() { return this.items.length === 0; }
    size() { return this.items.length; }
};

// Entity manager
window.EntityManager = class {
    constructor() {
        this.entities = new Map();
        this.nextId = 0;
    }
    add(entity) {
        const id = this.nextId++;
        this.entities.set(id, entity);
        return id;
    }
    remove(id) {
        this.entities.delete(id);
    }
    get(id) {
        return this.entities.get(id);
    }
    update() {
        this.entities.forEach(entity => entity.update());
    }
    draw() {
        this.entities.forEach(entity => entity.draw());
    }
};</pre>
        </section>

        <section>
            <h2>Complete Game Examples</h2>

            <h3>Simple Platformer</h3>
            <p>A basic platformer with gravity and collision:</p>
            <pre class="code-editor">
// Init code
window._state = {
    player: {
        x: 32, y: 32,
        velocity: { x: 0, y: 0 }
    },
    platforms: [
        { x: 10, y: 50, width: 20, height: 2 },
        { x: 40, y: 40, width: 20, height: 2 }
    ],
    gravity: 0.5,
    jumpForce: -8
};

document.onkeydown = (e) => {
    if (e.key === 'ArrowUp' && window._state.player.canJump) {
        window._state.player.velocity.y = window._state.jumpForce;
    }
};

// Update code
(function(){
    const state = window._state;
    const player = state.player;
    
    // Apply gravity
    player.velocity.y += state.gravity;
    
    // Move player
    if (window._input.keys.ArrowLeft) {
        player.velocity.x = -2;
    } else if (window._input.keys.ArrowRight) {
        player.velocity.x = 2;
    } else {
        player.velocity.x *= 0.8; // Friction
    }
    
    // Update position
    player.x += player.velocity.x;
    player.y += player.velocity.y;
    
    // Check platform collisions
    player.canJump = false;
    state.platforms.forEach(platform => {
        if (rectIntersect(
            player.x, player.y, 4, 4,
            platform.x, platform.y, 
            platform.width, platform.height
        )) {
            if (player.velocity.y > 0) {
                player.y = platform.y - 4;
                player.velocity.y = 0;
                player.canJump = true;
            }
        }
    });
    
    // Keep in bounds
    player.x = clamp(player.x, 0, 60);
    player.y = clamp(player.y, 0, 60);
    
    // Draw
    const ctx = window._ctx;
    const scale = canvas.width / 64;
    
    // Clear screen
    ctx.fillStyle = '#000033';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw platforms
    ctx.fillStyle = '#666666';
    state.platforms.forEach(platform => {
        ctx.fillRect(
            platform.x * scale,
            platform.y * scale,
            platform.width * scale,
            platform.height * scale
        );
    });
    
    // Draw player
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(
        player.x * scale,
        player.y * scale,
        4 * scale,
        4 * scale
    );
})();</pre>

            <h3>Shoot 'em Up Game</h3>
            <p>A simple shooter with enemies and projectiles:</p>
            <pre class="code-editor">
// Init code
window._state = {
    player: {
        x: 32, y: 56,
        width: 4, height: 4,
        cooldown: 0
    },
    bullets: [],
    enemies: [],
    score: 0,
    spawnTimer: 0
};

// Create audio
window._synth = new Tone.Synth().toDestination();
window._effects = {
    shoot: () => window._synth.triggerAttackRelease('C5', '32n'),
    hit: () => window._synth.triggerAttackRelease('G3', '16n'),
    explode: () => window._synth.triggerAttackRelease(['C2', 'G2'], '8n')
};

// Update code
(function(){
    const state = window._state;
    const ctx = window._ctx;
    const scale = canvas.width / 64;
    
    // Clear screen
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Move player
    if (window._input.keys.ArrowLeft) {
        state.player.x = Math.max(0, state.player.x - 2);
    }
    if (window._input.keys.ArrowRight) {
        state.player.x = Math.min(60, state.player.x + 2);
    }
    
    // Shooting
    state.player.cooldown--;
    if (window._input.keys.Space && state.player.cooldown <= 0) {
        state.bullets.push({
            x: state.player.x + 2,
            y: state.player.y,
            speed: -4
        });
        window._effects.shoot();
        state.player.cooldown = 10;
    }
    
    // Spawn enemies
    state.spawnTimer--;
    if (state.spawnTimer <= 0) {
        state.enemies.push({
            x: random(0, 60),
            y: -4,
            speed: random(1, 2) / 2
        });
        state.spawnTimer = 60;
    }
    
    // Update bullets
    for (let i = state.bullets.length - 1; i >= 0; i--) {
        const bullet = state.bullets[i];
        bullet.y += bullet.speed;
        if (bullet.y < -2) {
            state.bullets.splice(i, 1);
            continue;
        }
        
        // Check bullet collisions
        for (let j = state.enemies.length - 1; j >= 0; j--) {
            const enemy = state.enemies[j];
            if (rectIntersect(
                bullet.x, bullet.y, 1, 2,
                enemy.x, enemy.y, 4, 4
            )) {
                state.bullets.splice(i, 1);
                state.enemies.splice(j, 1);
                state.score += 10;
                window._effects.hit();
                break;
            }
        }
    }
    
    // Update enemies
    for (let i = state.enemies.length - 1; i >= 0; i--) {
        const enemy = state.enemies[i];
        enemy.y += enemy.speed;
        
        // Check player collision
        if (rectIntersect(
            enemy.x, enemy.y, 4, 4,
            state.player.x, state.player.y, 4, 4
        )) {
            window._effects.explode();
            state.gameOver = true;
        }
        
        if (enemy.y > 64) {
            state.enemies.splice(i, 1);
        }
    }
    
    // Draw everything
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(
        state.player.x * scale,
        state.player.y * scale,
        4 * scale,
        4 * scale
    );
    
    ctx.fillStyle = '#ffff00';
    state.bullets.forEach(bullet => {
        ctx.fillRect(
            bullet.x * scale,
            bullet.y * scale,
            scale,
            2 * scale
        );
    });
    
    ctx.fillStyle = '#ff0000';
    state.enemies.forEach(enemy => {
        ctx.fillRect(
            enemy.x * scale,
            enemy.y * scale,
            4 * scale,
            4 * scale
        );
    });
    
    // Draw score
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.fillText(`Score: ${state.score}`, 10, 20);
    
    if (state.gameOver) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '24px monospace';
        ctx.fillText('Game Over!', 
            canvas.width/4, canvas.height/2);
    }
})();</pre>

            <h2>Tips and Best Practices</h2>
            <h3>Performance Optimization</h3>
            <ul>
                <li>Use <code>window._state</code> for persistent game state</li>
                <li>Avoid creating new objects in the update loop</li>
                <li>Use the built-in entity manager for game objects</li>
                <li>Pre-calculate values when possible</li>
                <li>Use the debug display mode (3) to monitor performance</li>
                <li>Batch similar draw operations together</li>
                <li>Use object pooling for frequently created/destroyed objects</li>
                <li>Limit the number of active entities</li>
            </ul>

            <h3>Code Organization</h3>
            <pre class="code-editor">
// Initialize all game systems
window._state = {
    // Game state
    player: createPlayer(),
    entities: new EntityManager(),
    score: 0,
    
    // System state
    paused: false,
    debug: false,
    
    // Scene management
    currentScene: 'title',
    scenes: {
        title: createTitleScene(),
        game: createGameScene(),
        over: createGameOverScene()
    }
};

// Update logic
function update() {
    const scene = window._state.scenes[window._state.currentScene];
    if (scene && !window._state.paused) {
        scene.update();
    }
}

// Render logic
function render() {
    const scene = window._state.scenes[window._state.currentScene];
    if (scene) {
        scene.render();
    }
    if (window._state.debug) {
        renderDebugInfo();
    }
}</pre>

            <h3>Debugging Tips</h3>
            <ul>
                <li>Use <code>console.log()</code> for basic debugging</li>
                <li>Set <code>window._state.debug = true</code> to show debug info</li>
                <li>Use the browser's developer tools to inspect state</li>
                <li>Add visual indicators for hitboxes and collision areas</li>
                <li>Implement a debug console with commands</li>
            </ul>

            <h3>Common Pitfalls</h3>
            <ul>
                <li>Not clearing the screen each frame</li>
                <li>Forgetting to scale coordinates with canvas size</li>
                <li>Creating new objects every frame</li>
                <li>Not handling edge cases in collision detection</li>
                <li>Inefficient collision checking (checking everything against everything)</li>
                <li>Not cleaning up event listeners</li>
            </ul>
        </section>
Tone.Transport.start();</pre>

            <h3>Sound Effects System</h3>
            <pre class="code-editor">
// Define sound effects
window._audio = {
    effects: {
        jump: () => synth.triggerAttackRelease("G5", "16n"),
        coin: () => poly.triggerAttackRelease(["C6", "E6"], "16n"),
        hit: () => drum.triggerAttackRelease("C2", "8n")
    },
    music: {
        start: (track) => {}, // Start background music
        stop: () => {},      // Stop all music
        fade: (duration) => {} // Fade out current music
    }
};</pre>

            <h3>Advanced Audio</h3>
            <pre class="code-editor">
// Polyphonic synthesis
const poly = new Tone.PolySynth().toDestination();
poly.triggerAttackRelease(["C4", "E4", "G4"], "4n");

// Effects
const reverb = new Tone.Reverb(2.5).toDestination();
const synth = new Tone.Synth().connect(reverb);

// Sequences
const sequence = new Tone.Sequence((time, note) => {
    synth.triggerAttackRelease(note, "8n", time);
}, ["C4", "E4", "G4", "B4"]).start(0);</pre>
        </section>

        <section>
            <h2>Game State Management</h2>
            <p>Best practices for managing game state:</p>
            <pre class="code-editor">
// Initialize game state in initCode
window._state = {
    player: { x: 32, y: 32, score: 0 },
    entities: [],
    gameOver: false
};

// Update state in updateCode
function updateGameState() {
    window._state.player.x += 1;
    window._state.score += 1;
}

// Access state anywhere
function drawScore() {
    ctx.fillText(`Score: ${window._state.score}`, 8, 8);
}</pre>
        </section>

        <section>
            <h2>Input Handling</h2>
            <p>Handle keyboard and mouse input:</p>
            <pre class="code-editor">
// Keyboard input
document.onkeydown = (e) => {
    switch(e.key) {
        case 'ArrowLeft': player.x -= 1; break;
        case 'ArrowRight': player.x += 1; break;
        case 'ArrowUp': player.y -= 1; break;
        case 'ArrowDown': player.y += 1; break;
        case ' ': // Space
            shoot(); break;
    }
};

// Mouse/Touch input
canvas.onclick = (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;
    handleClick(Math.floor(x), Math.floor(y));
};</pre>
        </section>

        <section>
            <h2>Math Utilities</h2>
            <p>Common math functions for game development:</p>
            <pre class="code-editor">
// Random integer between min (inclusive) and max (exclusive)
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

// Distance between two points
function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

// Keep a value between min and max
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}

// Linear interpolation
function lerp(start, end, t) {
    return start + (end - start) * t;
}</pre>
        </section>

        <section>
            <h2>Collision Detection</h2>
            <p>Basic collision detection methods:</p>
            <pre class="code-editor">
// Point vs Rectangle
function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px < rx + rw &&
           py >= ry && py < ry + rh;
}

// Rectangle vs Rectangle
function rectIntersect(r1x, r1y, r1w, r1h,
                      r2x, r2y, r2w, r2h) {
    return r1x < r2x + r2w && r1x + r1w > r2x &&
           r1y < r2y + r2h && r1y + r1h > r2y;
}

// Circle vs Circle
function circleIntersect(c1x, c1y, c1r,
                        c2x, c2y, c2r) {
    const dist = distance(c1x, c1y, c2x, c2y);
    return dist < c1r + c2r;
}</pre>
        </section>
    </main>
</body>
</html>