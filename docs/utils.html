        <section>
            <h2>Utility Methods</h2>

            <h3>Math Utilities</h3>
            <pre class="code-editor">
// Random number generation
window.random = (min, max) => 
    Math.floor(Math.random() * (max - min + 1)) + min;

// Value clamping
window.clamp = (value, min, max) => 
    Math.min(Math.max(value, min), max);

// Linear interpolation
window.lerp = (start, end, t) => 
    start + (end - start) * t;

// Distance calculation
window.distance = (x1, y1, x2, y2) => 
    Math.sqrt((x2-x1)**2 + (y2-y1)**2);

// Angle between points (in radians)
window.angle = (x1, y1, x2, y2) => 
    Math.atan2(y2 - y1, x2 - x1);</pre>

            <h3>Collision Detection</h3>
            <pre class="code-editor">
// Point vs Rectangle
window.pointInRect = (px, py, rx, ry, rw, rh) => 
    px >= rx && px < rx + rw && 
    py >= ry && py < ry + rh;

// Rectangle vs Rectangle
window.rectIntersect = (r1x, r1y, r1w, r1h, 
                       r2x, r2y, r2w, r2h) => 
    r1x < r2x + r2w && r1x + r1w > r2x &&
    r1y < r2y + r2h && r1y + r1h > r2y;

// Circle vs Circle
window.circleIntersect = (c1x, c1y, c1r, 
                         c2x, c2y, c2r) => 
    distance(c1x, c1y, c2x, c2y) < c1r + c2r;

// Point vs Circle
window.pointInCircle = (px, py, cx, cy, cr) =>
    distance(px, py, cx, cy) < cr;</pre>

            <h3>Vector Operations</h3>
            <pre class="code-editor">
// Create a vector
window.vector = (x, y) => ({ x, y });

// Add vectors
window.vectorAdd = (v1, v2) => 
    vector(v1.x + v2.x, v1.y + v2.y);

// Scale vector
window.vectorScale = (v, scale) => 
    vector(v.x * scale, v.y * scale);

// Vector magnitude
window.vectorMagnitude = (v) => 
    Math.sqrt(v.x * v.x + v.y * v.y);

// Normalize vector
window.vectorNormalize = (v) => {
    const mag = vectorMagnitude(v);
    return mag === 0 ? v : vectorScale(v, 1/mag);
};</pre>

            <h3>Color Manipulation</h3>
            <pre class="code-editor">
// RGB to Hex
window.rgbToHex = (r, g, b) => 
    '#' + [r, g, b]
        .map(x => Math.floor(x)
        .toString(16)
        .padStart(2, '0'))
        .join('');

// Hex to RGB
window.hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

// Lerp between colors
window.lerpColor = (color1, color2, t) => {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    return rgbToHex(
        lerp(c1.r, c2.r, t),
        lerp(c1.g, c2.g, t),
        lerp(c1.b, c2.b, t)
    );
};</pre>

            <h3>Data Structures</h3>
            <pre class="code-editor">
// Grid creation
window.createGrid = (width, height, defaultValue = 0) =>
    Array(height).fill().map(() => 
        Array(width).fill(defaultValue));

// Queue implementation
window.Queue = class {
    constructor() {
        this.items = [];
    }
    enqueue(item) { this.items.push(item); }
    dequeue() { return this.items.shift(); }
    peek() { return this.items[0]; }
    isEmpty() { return this.items.length === 0; }
    size() { return this.items.length; }
};

// Entity manager
window.EntityManager = class {
    constructor() {
        this.entities = new Map();
        this.nextId = 0;
    }
    add(entity) {
        const id = this.nextId++;
        this.entities.set(id, entity);
        return id;
    }
    remove(id) {
        this.entities.delete(id);
    }
    get(id) {
        return this.entities.get(id);
    }
    update() {
        this.entities.forEach(entity => entity.update());
    }
    draw() {
        this.entities.forEach(entity => entity.draw());
    }
};</pre>
        </section>