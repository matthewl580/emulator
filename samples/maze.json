{
  "initCode": "// Maze Game Init\nwindow._state = {\n  maze: [],\n  player: { x: 1, y: 1 },\n  exit: { x: 0, y: 0 },\n  torchRadius: 5,\n  gameOver: false,\n  victory: false\n};\n\n// Generate maze using recursive backtracking\nfunction generateMaze(width, height) {\n  // Initialize maze with walls\n  const maze = Array(height).fill().map(() => Array(width).fill(1));\n  const stack = [];\n  const start = { x: 1, y: 1 };\n\n  function carve(x, y) {\n    maze[y][x] = 0;\n    const directions = [\n      { dx: 0, dy: -2 }, // Up\n      { dx: 2, dy: 0 },  // Right\n      { dx: 0, dy: 2 },  // Down\n      { dx: -2, dy: 0 }  // Left\n    ];\n    \n    // Shuffle directions\n    for (let i = directions.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [directions[i], directions[j]] = [directions[j], directions[i]];\n    }\n\n    directions.forEach(dir => {\n      const nx = x + dir.dx;\n      const ny = y + dir.dy;\n      if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {\n        maze[y + dir.dy/2][x + dir.dx/2] = 0;\n        carve(nx, ny);\n      }\n    });\n  }\n\n  carve(start.x, start.y);\n\n  // Create exit\n  const exit = { x: width - 2, y: height - 2 };\n  maze[exit.y][exit.x] = 0;\n  window._state.exit = exit;\n  window._state.maze = maze;\n}\n\ngenerateLevel();\n\n// Setup audio\ntry {\n  window._synth = new Tone.Synth().toDestination();\n  window._effects = {\n    move: () => window._synth.triggerAttackRelease('C4', '32n'),\n    wall: () => window._synth.triggerAttackRelease('C2', '16n'),\n    victory: () => window._synth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n')\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
  "updateCode": "// Maze Game Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  // Input handling\n  document.onkeydown = (e) => {\n    if (state.gameOver) return;\n    \n    const newPos = { ...state.player };\n    switch(e.key) {\n      case 'ArrowLeft': newPos.x--; break;\n      case 'ArrowRight': newPos.x++; break;\n      case 'ArrowUp': newPos.y--; break;\n      case 'ArrowDown': newPos.y++; break;\n    }\n\n    // Check collision\n    if (state.maze[newPos.y]?.[newPos.x] === 0) {\n      state.player = newPos;\n      if (window._effects) window._effects.move();\n    } else if (window._effects) {\n      window._effects.wall();\n    }\n\n    // Check victory\n    if (newPos.x === state.exit.x && newPos.y === state.exit.y) {\n      state.victory = true;\n      state.gameOver = true;\n      if (window._effects) window._effects.victory();\n    }\n  };\n\n  // Clear screen\n  ctx.fillStyle = '#000000';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const scale = canvas.width / 64;\n  const cellSize = 4;\n\n  // Create torch gradient\n  const gradient = ctx.createRadialGradient(\n    state.player.x * cellSize * scale,\n    state.player.y * cellSize * scale,\n    0,\n    state.player.x * cellSize * scale,\n    state.player.y * cellSize * scale,\n    state.torchRadius * cellSize * scale\n  );\n  gradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');\n  gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');\n\n  // Draw maze\n  for (let y = 0; y < state.maze.length; y++) {\n    for (let x = 0; x < state.maze[y].length; x++) {\n      const cell = state.maze[y][x];\n      const dx = x * cellSize * scale;\n      const dy = y * cellSize * scale;\n      \n      ctx.fillStyle = cell === 1 ? '#666666' : '#222222';\n      ctx.fillRect(dx, dy, cellSize * scale, cellSize * scale);\n    }\n  }\n\n  // Apply torch effect\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Draw exit\n  ctx.fillStyle = '#00ff00';\n  ctx.fillRect(\n    state.exit.x * cellSize * scale,\n    state.exit.y * cellSize * scale,\n    cellSize * scale,\n    cellSize * scale\n  );\n\n  // Draw player\n  ctx.fillStyle = '#ffff00';\n  ctx.fillRect(\n    state.player.x * cellSize * scale,\n    state.player.y * cellSize * scale,\n    cellSize * scale,\n    cellSize * scale\n  );\n\n  // Victory screen\n  if (state.victory) {\n    ctx.fillStyle = '#ffffff';\n    ctx.font = '24px monospace';\n    ctx.fillText('Escaped!', canvas.width/4, canvas.height/2);\n  }\n})();",
  "displayMode": "1",
  "timestamp": "2025-11-04T00:00:00.000Z"
}