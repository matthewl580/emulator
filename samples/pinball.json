{
	"initCode": "// Pinball Init\n// One-time state setup (runs once)\nwindow._state = {\n  ball: { x: 58, y: 40, vx: 0, vy: 0, active: false },\n  flippers: [\n    { x: 20, y: 56, angle: 0.45, base: 0.45, target: 0.45, active: false, direction: 1 },\n    { x: 44, y: 56, angle: -0.45, base: -0.45, target: -0.45, active: false, direction: -1 }\n  ],\n  bumpers: [\n    { x: 20, y: 20, radius: 3, lastHit: 0 },\n    { x: 44, y: 20, radius: 3, lastHit: 0 },\n    { x: 32, y: 32, radius: 4, lastHit: 0 }\n  ],\n  score: 0,\n  balls: 3,\n  lastBumper: null,\n  combo: 1,\n  gameOver: false,\n  message: '',\n  messageTimer: 0,\n  // tuning constants stored in state so editor can tweak easily\n  GRAVITY: 0.18,\n  FRICTION: 0.995,\n  FLIPPER_SPEED: 0.22,\n  FLIPPER_FORCE: 6,\n  BUMPER_STRENGTH: 5,\n  MAX_SPEED: 1\n};\n\n// Input handlers: attach once during init to avoid re-binding each frame\ndocument.addEventListener('keydown', (e) => {\n  const s = window._state;\n  if (!s || s.gameOver) return;\n  if (e.key === 'ArrowLeft') {\n    s.flippers[0].active = true;\n    if (window._effects) window._effects.flipper();\n  } else if (e.key === 'ArrowRight') {\n    s.flippers[1].active = true;\n    if (window._effects) window._effects.flipper();\n  } else if (e.key === ' ') {\n    // gentle launch impulse instead of a huge velocity set\n    if (!s.ball.active) {\n      s.ball.vy = -12;\n      s.ball.vx += ((Math.random()+0.5) * 40);\n      s.ball.active = true;\n      if (window._effects) window._effects.launch();\n    }\n  }\n});\ndocument.addEventListener('keyup', (e) => {\n  const s = window._state;\n  if (!s) return;\n  if (e.key === 'ArrowLeft') s.flippers[0].active = false;\n  if (e.key === 'ArrowRight') s.flippers[1].active = false;\n});\n\n// Setup audio (optional)\ntry {\n  window._synth = new Tone.PolySynth().toDestination();\n  const reverb = new Tone.Reverb({ decay: 1.2, wet: 0.25 }).toDestination();\n  window._effects = {\n    flipper: () => {\n      window._synth.triggerAttackRelease('C3', '32n', undefined, 0.6);\n    },\n    bumper: (combo) => {\n      const notes = ['C4', 'E4', 'G4', 'C5'];\n      const note = notes[Math.min(combo-1, notes.length-1)];\n      window._synth.triggerAttackRelease(note, '16n', undefined, 0.75);\n    },\n    launch: () => {\n      window._synth.triggerAttackRelease(['G4', 'B4'], '8n', undefined, 0.6);\n    },\n    lose: () => {\n      window._synth.triggerAttackRelease('C3', '4n', undefined, 0.6);\n    },\n    gameOver: () => {\n      window._synth.triggerAttackRelease(['C3', 'G2'], '2n', undefined, 0.6);\n    }\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
	"updateCode": "// Pinball Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  const scale = canvas.width / 64;\n  const FLIPPER_LENGTH = 12;\n  const BALL_RADIUS = 1;\n\n  // Smooth flipper movement toward target angle based on active state\n  state.flippers.forEach(f => {\n    const target = f.active ? (f.base - 0.65 * Math.sign(f.base)) : f.base;\n    // move angle toward target (spring-like smoothing)\n    f.angle += (target - f.angle) * 0.25;\n    f.target = target;\n  });\n\n  // Update ball physics\n  if (state.ball.active) {\n    // gravity and damping\n    state.ball.vy += state.GRAVITY;\n    state.ball.vx *= state.FRICTION;\n    state.ball.vy *= state.FRICTION;\n\n    // integrate\n    state.ball.x += state.ball.vx;\n    state.ball.y += state.ball.vy;\n\n    // clamp max speed to avoid runaway\n    const speed = Math.hypot(state.ball.vx, state.ball.vy);\n    if (speed > state.MAX_SPEED) {\n      const s = state.MAX_SPEED / speed;\n      state.ball.vx *= s; state.ball.vy *= s;\n    }\n\n    // Wall collisions (soft bounce)\n    if (state.ball.x < 4 + BALL_RADIUS) { state.ball.x = 4 + BALL_RADIUS; state.ball.vx *= -0.6; }\n    if (state.ball.x > 60 - BALL_RADIUS) { state.ball.x = 60 - BALL_RADIUS; state.ball.vx *= -0.6; }\n    if (state.ball.y < 4 + BALL_RADIUS) { state.ball.y = 4 + BALL_RADIUS; state.ball.vy *= -0.6; }\n\n    // Flipper collisions (apply impulse instead of overwriting velocity)\n    state.flippers.forEach(flipper => {\n      const dx = state.ball.x - flipper.x;\n      const dy = state.ball.y - flipper.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if (dist < FLIPPER_LENGTH) {\n        // flipper orientation (pivot-based)\n        const flipperAngle = flipper.angle * flipper.direction;\n        const normalAngle = flipperAngle + Math.PI/2;\n        const nx = Math.cos(normalAngle);\n        const ny = Math.sin(normalAngle);\n        // impulse magnitude smaller and scaled by whether flipper is active\n        const impulse = state.FLIPPER_FORCE * (flipper.active ? 1.3 : 0.7);\n        state.ball.vx += nx * impulse * 0.12;\n        state.ball.vy += ny * impulse * 0.12;\n        // small positional nudge to avoid sticking\n        state.ball.x += nx * 0.5;\n        state.ball.y += ny * 0.5;\n      }\n    });\n\n    // Bumper collisions with cooldown to prevent multiple triggers per frame\n    const now = Date.now();\n    state.bumpers.forEach(bumper => {\n      const dx = state.ball.x - bumper.x;\n      const dy = state.ball.y - bumper.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if (dist < bumper.radius + BALL_RADIUS) {\n        // simple cooldown\n        if (now - (bumper.lastHit || 0) > 120) {\n          bumper.lastHit = now;\n          const angle = Math.atan2(dy, dx);\n          const impulse = state.BUMPER_STRENGTH * (state.combo > 1 ? Math.min(1 + state.combo*0.15, 2) : 1);\n          state.ball.vx = Math.cos(angle) * impulse * 0.9 + state.ball.vx * 0.1;\n          state.ball.vy = Math.sin(angle) * impulse * 0.9 + state.ball.vy * 0.1;\n\n          if (bumper === state.lastBumper) { state.combo++; } else { state.combo = 1; }\n          state.lastBumper = bumper;\n          state.score += 100 * state.combo;\n          state.message = `${100 * state.combo} pts!`;\n          state.messageTimer = 30;\n          if (window._effects) window._effects.bumper(state.combo);\n        }\n      }\n    });\n\n    // Ball lost (fell below playfield)\n    if (state.ball.y > 300) {\n      state.balls--;\n      if (window._effects) window._effects.lose();\n      if (state.balls <= 0) {\n        state.gameOver = true;\n        if (window._effects) window._effects.gameOver();\n      } else {\n        state.ball = { x: 58, y: 40, vx: 0, vy: 0, active: false };\n        state.lastBumper = null; state.combo = 1;\n      }\n    }\n  }\n\n  // Update message timer\n  if (state.messageTimer > 0) state.messageTimer--;\n\n  // Clear screen & draw\n  ctx.fillStyle = '#000044'; ctx.fillRect(0,0,canvas.width,canvas.height);\n\n  // Draw walls\n  ctx.strokeStyle = '#4444ff'; ctx.lineWidth = scale * 2; ctx.beginPath(); ctx.moveTo(2*scale,2*scale); ctx.lineTo(62*scale,2*scale); ctx.lineTo(62*scale,60*scale); ctx.lineTo(2*scale,60*scale); ctx.lineTo(2*scale,2*scale); ctx.stroke();\n\n  // Draw flippers\n  ctx.fillStyle = '#4444ff';\n  state.flippers.forEach(flipper => {\n    ctx.save(); ctx.translate(flipper.x * scale, flipper.y * scale); ctx.rotate(flipper.angle * flipper.direction); ctx.fillRect(-FLIPPER_LENGTH/2 * scale, -2 * scale, FLIPPER_LENGTH * scale, 4 * scale); ctx.restore();\n  });\n\n  // Draw bumpers\n  state.bumpers.forEach(bumper => { ctx.fillStyle = bumper === state.lastBumper ? '#ff4444' : '#4444ff'; ctx.beginPath(); ctx.arc(bumper.x*scale, bumper.y*scale, bumper.radius*scale, 0, Math.PI*2); ctx.fill(); });\n\n  // Draw ball\n  ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(state.ball.x*scale, state.ball.y*scale, BALL_RADIUS*scale, 0, Math.PI*2); ctx.fill();\n\n  // Draw launcher\n  ctx.fillStyle = '#4444ff'; ctx.fillRect(58*scale, 40*scale, 2*scale, 20*scale);\n\n  // Draw HUD\n  ctx.fillStyle = '#ffffff'; ctx.font = '20px monospace'; ctx.fillText(`Score: ${state.score}`, 20, 30); ctx.fillText(`Balls: ${state.balls}`, canvas.width - 120, 30);\n  if (state.combo > 1) ctx.fillText(`Combo: x${state.combo}`, 20, 60);\n\n  // Message\n  if (state.messageTimer > 0) { ctx.font = '24px monospace'; ctx.fillStyle = `rgba(255,255,255,${state.messageTimer/30})`; ctx.fillText(state.message, canvas.width/2 - ctx.measureText(state.message).width/2, canvas.height/2); }\n\n  // Game over overlay\n  if (state.gameOver) { ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#ffffff'; ctx.font='40px monospace'; ctx.fillText('Game Over!', canvas.width/4, canvas.height/2); ctx.font='20px monospace'; ctx.fillText(`Final Score: ${state.score}`, canvas.width/4, canvas.height/2 + 40); }\n})();",
	"displayMode": "1",
	"timestamp": "2025-11-04T00:00:00.000Z"
}
