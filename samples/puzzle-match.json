{
  "initCode": "// Puzzle Match Init\nwindow._state = {\n  grid: Array(8 * 8).fill().map(() => Math.floor(Math.random() * 5)),\n  selected: null,\n  score: 0,\n  moves: 30,\n  gameOver: false,\n  animations: []\n};\n\n// Setup audio\ntry {\n  window._synth = new Tone.Synth().toDestination();\n  window._effects = {\n    select: () => window._synth.triggerAttackRelease('C5', '32n'),\n    match: () => window._synth.triggerAttackRelease(['E5', 'G5'], '16n'),\n    invalid: () => window._synth.triggerAttackRelease('C3', '8n')\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
  "updateCode": "// Puzzle Match Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  const COLORS = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];\n  const scale = canvas.width / 64;\n  const TILE_SIZE = 8;\n\n  // Handle clicks\n  canvas.onclick = (e) => {\n    if (state.gameOver) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = Math.floor((e.clientX - rect.left) / rect.width * 8);\n    const y = Math.floor((e.clientY - rect.top) / rect.height * 8);\n    const index = y * 8 + x;\n\n    if (state.selected === null) {\n      state.selected = index;\n      if (window._effects) window._effects.select();\n    } else {\n      // Check if adjacent\n      const sx = state.selected % 8;\n      const sy = Math.floor(state.selected / 8);\n      if ((Math.abs(x - sx) === 1 && y === sy) ||\n          (Math.abs(y - sy) === 1 && x === sx)) {\n        // Swap tiles\n        const temp = state.grid[index];\n        state.grid[index] = state.grid[state.selected];\n        state.grid[state.selected] = temp;\n\n        // Check for matches\n        const matches = findMatches();\n        if (matches.length > 0) {\n          state.score += matches.length * 10;\n          removeMatches(matches);\n          if (window._effects) window._effects.match();\n          state.moves--;\n        } else {\n          // Swap back if no matches\n          const temp = state.grid[index];\n          state.grid[index] = state.grid[state.selected];\n          state.grid[state.selected] = temp;\n          if (window._effects) window._effects.invalid();\n        }\n      }\n      state.selected = null;\n    }\n  };\n\n  function findMatches() {\n    const matches = new Set();\n    \n    // Check rows\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 6; x++) {\n        const color = state.grid[y * 8 + x];\n        if (color === state.grid[y * 8 + x + 1] &&\n            color === state.grid[y * 8 + x + 2]) {\n          matches.add(y * 8 + x);\n          matches.add(y * 8 + x + 1);\n          matches.add(y * 8 + x + 2);\n        }\n      }\n    }\n\n    // Check columns\n    for (let x = 0; x < 8; x++) {\n      for (let y = 0; y < 6; y++) {\n        const color = state.grid[y * 8 + x];\n        if (color === state.grid[(y + 1) * 8 + x] &&\n            color === state.grid[(y + 2) * 8 + x]) {\n          matches.add(y * 8 + x);\n          matches.add((y + 1) * 8 + x);\n          matches.add((y + 2) * 8 + x);\n        }\n      }\n    }\n\n    return Array.from(matches);\n  }\n\n  function removeMatches(matches) {\n    // Remove matched tiles\n    matches.forEach(index => {\n      for (let y = Math.floor(index / 8); y > 0; y--) {\n        state.grid[y * 8 + (index % 8)] = state.grid[(y - 1) * 8 + (index % 8)];\n      }\n      state.grid[index % 8] = Math.floor(Math.random() * 5);\n    });\n  }\n\n  // Clear screen\n  ctx.fillStyle = '#000000';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Draw grid\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const index = y * 8 + x;\n      ctx.fillStyle = COLORS[state.grid[index]];\n      ctx.fillRect(x * TILE_SIZE * scale + scale,\n                   y * TILE_SIZE * scale + scale,\n                   TILE_SIZE * scale - scale * 2,\n                   TILE_SIZE * scale - scale * 2);\n\n      if (index === state.selected) {\n        ctx.strokeStyle = '#ffffff';\n        ctx.strokeRect(x * TILE_SIZE * scale,\n                      y * TILE_SIZE * scale,\n                      TILE_SIZE * scale,\n                      TILE_SIZE * scale);\n      }\n    }\n  }\n\n  // Draw score and moves\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '12px monospace';\n  ctx.fillText(`Score: ${state.score}  Moves: ${state.moves}`, 10, 20);\n\n  // Check game over\n  if (state.moves <= 0) {\n    state.gameOver = true;\n    ctx.fillStyle = '#ffffff';\n    ctx.font = '24px monospace';\n    ctx.fillText('Game Over!', canvas.width/4, canvas.height/2);\n  }\n})();",
  "displayMode": "1",
  "timestamp": "2025-11-04T00:00:00.000Z"
}