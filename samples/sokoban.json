{
  "initCode": "// Sokoban Clone Init\nwindow._state = {\n  player: { x: 2, y: 2 },\n  boxes: [\n    { x: 4, y: 4 },\n    { x: 4, y: 5 },\n    { x: 5, y: 4 }\n  ],\n  targets: [\n    { x: 8, y: 8 },\n    { x: 8, y: 9 },\n    { x: 9, y: 8 }\n  ],\n  walls: [\n    // Room borders\n    { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 3, y: 1 }, { x: 4, y: 1 },\n    { x: 5, y: 1 }, { x: 6, y: 1 }, { x: 7, y: 1 }, { x: 8, y: 1 },\n    { x: 9, y: 1 }, { x: 10, y: 1 },\n    { x: 1, y: 10 }, { x: 2, y: 10 }, { x: 3, y: 10 }, { x: 4, y: 10 },\n    { x: 5, y: 10 }, { x: 6, y: 10 }, { x: 7, y: 10 }, { x: 8, y: 10 },\n    { x: 9, y: 10 }, { x: 10, y: 10 },\n    { x: 1, y: 2 }, { x: 1, y: 3 }, { x: 1, y: 4 }, { x: 1, y: 5 },\n    { x: 1, y: 6 }, { x: 1, y: 7 }, { x: 1, y: 8 }, { x: 1, y: 9 },\n    { x: 10, y: 2 }, { x: 10, y: 3 }, { x: 10, y: 4 }, { x: 10, y: 5 },\n    { x: 10, y: 6 }, { x: 10, y: 7 }, { x: 10, y: 8 }, { x: 10, y: 9 },\n    // Inner walls\n    { x: 3, y: 3 }, { x: 3, y: 4 }, { x: 3, y: 5 },\n    { x: 7, y: 5 }, { x: 7, y: 6 }, { x: 7, y: 7 }\n  ],\n  moves: 0,\n  pushes: 0,\n  undoStack: [],\n  gameOver: false\n};\n\n// Setup audio\ntry {\n  window._synth = new Tone.Synth().toDestination();\n  window._effects = {\n    move: () => window._synth.triggerAttackRelease('C4', '32n'),\n    push: () => window._synth.triggerAttackRelease('E4', '16n'),\n    victory: () => window._synth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n')\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
  "updateCode": "// Sokoban Clone Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  // Input handling\n  document.onkeydown = (e) => {\n    if (state.gameOver) return;\n\n    let dx = 0, dy = 0;\n    switch(e.key) {\n      case 'ArrowLeft': dx = -1; break;\n      case 'ArrowRight': dx = 1; break;\n      case 'ArrowUp': dy = -1; break;\n      case 'ArrowDown': dy = 1; break;\n      case 'z':\n        if (e.ctrlKey && state.undoStack.length > 0) {\n          const previousState = state.undoStack.pop();\n          state.player = { ...previousState.player };\n          state.boxes = previousState.boxes.map(box => ({ ...box }));\n          state.moves--;\n          if (previousState.pushed) state.pushes--;\n          return;\n        }\n        break;\n    }\n\n    if (dx === 0 && dy === 0) return;\n\n    const newPos = { x: state.player.x + dx, y: state.player.y + dy };\n\n    // Check wall collision\n    if (state.walls.some(wall => wall.x === newPos.x && wall.y === newPos.y)) {\n      return;\n    }\n\n    // Check box collision\n    const box = state.boxes.find(box => box.x === newPos.x && box.y === newPos.y);\n    if (box) {\n      const newBoxPos = { x: box.x + dx, y: box.y + dy };\n      \n      // Check if box can be pushed\n      if (state.walls.some(wall => wall.x === newBoxPos.x && wall.y === newBoxPos.y) ||\n          state.boxes.some(b => b.x === newBoxPos.x && b.y === newBoxPos.y)) {\n        return;\n      }\n\n      // Save state for undo\n      state.undoStack.push({\n        player: { ...state.player },\n        boxes: state.boxes.map(box => ({ ...box })),\n        pushed: true\n      });\n\n      // Move box\n      box.x = newBoxPos.x;\n      box.y = newBoxPos.y;\n      state.pushes++;\n      if (window._effects) window._effects.push();\n    } else {\n      // Save state for undo\n      state.undoStack.push({\n        player: { ...state.player },\n        boxes: state.boxes.map(box => ({ ...box })),\n        pushed: false\n      });\n\n      if (window._effects) window._effects.move();\n    }\n\n    // Move player\n    state.player = newPos;\n    state.moves++;\n\n    // Check victory\n    if (state.targets.every(target =>\n      state.boxes.some(box => box.x === target.x && box.y === target.y)\n    )) {\n      state.gameOver = true;\n      if (window._effects) window._effects.victory();\n    }\n  };\n\n  // Clear screen\n  ctx.fillStyle = '#2a2a2a';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const scale = canvas.width / 64;\n  const cellSize = 5;\n\n  // Draw floor pattern\n  ctx.fillStyle = '#3a3a3a';\n  for (let y = 0; y < 12; y++) {\n    for (let x = 0; x < 12; x++) {\n      if ((x + y) % 2 === 0) {\n        ctx.fillRect(x * cellSize * scale,\n                     y * cellSize * scale,\n                     cellSize * scale,\n                     cellSize * scale);\n      }\n    }\n  }\n\n  // Draw targets\n  ctx.fillStyle = '#886600';\n  state.targets.forEach(target => {\n    ctx.fillRect(target.x * cellSize * scale,\n                 target.y * cellSize * scale,\n                 cellSize * scale,\n                 cellSize * scale);\n  });\n\n  // Draw walls\n  ctx.fillStyle = '#666666';\n  state.walls.forEach(wall => {\n    ctx.fillRect(wall.x * cellSize * scale,\n                 wall.y * cellSize * scale,\n                 cellSize * scale,\n                 cellSize * scale);\n  });\n\n  // Draw boxes\n  state.boxes.forEach(box => {\n    const onTarget = state.targets.some(target =>\n      target.x === box.x && target.y === box.y\n    );\n\n    ctx.fillStyle = onTarget ? '#88ff88' : '#884400';\n    ctx.fillRect(box.x * cellSize * scale + scale,\n                 box.y * cellSize * scale + scale,\n                 cellSize * scale - scale * 2,\n                 cellSize * scale - scale * 2);\n  });\n\n  // Draw player\n  ctx.fillStyle = '#4444ff';\n  ctx.fillRect(state.player.x * cellSize * scale + scale,\n               state.player.y * cellSize * scale + scale,\n               cellSize * scale - scale * 2,\n               cellSize * scale - scale * 2);\n\n  // Draw HUD\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '12px monospace';\n  ctx.fillText(`Moves: ${state.moves}  Pushes: ${state.pushes}`, 10, 20);\n\n  // Victory screen\n  if (state.gameOver) {\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    ctx.fillStyle = '#ffffff';\n    ctx.font = '24px monospace';\n    ctx.fillText('Level Complete!', canvas.width/4, canvas.height/2);\n    ctx.font = '16px monospace';\n    ctx.fillText(`Moves: ${state.moves}  Pushes: ${state.pushes}`, \n                 canvas.width/4, canvas.height/2 + 30);\n  }\n})();",
  "displayMode": "1",
  "timestamp": "2025-11-04T00:00:00.000Z"
}