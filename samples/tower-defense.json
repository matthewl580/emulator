{
  "initCode": "// Tower Defense Init\nwindow._state = {\n  towers: [],\n  enemies: [],\n  projectiles: [],\n  path: [\n    {x: 0, y: 32},\n    {x: 16, y: 32},\n    {x: 16, y: 16},\n    {x: 48, y: 16},\n    {x: 48, y: 48},\n    {x: 64, y: 48}\n  ],\n  gold: 100,\n  lives: 20,\n  wave: 0,\n  waveTimer: 180,\n  enemiesLeft: 0,\n  selected: null,\n  towerTypes: [\n    {name: 'Basic', cost: 50, range: 15, damage: 10, rate: 30},\n    {name: 'Sniper', cost: 100, range: 30, damage: 30, rate: 60},\n    {name: 'Rapid', cost: 75, range: 10, damage: 5, rate: 10}\n  ],\n  gameOver: false\n};\n\n// Setup audio\ntry {\n  window._synth = new Tone.PolySynth().toDestination();\n  window._effects = {\n    shoot: () => window._synth.triggerAttackRelease('C5', '32n'),\n    hit: () => window._synth.triggerAttackRelease('G3', '16n'),\n    build: () => window._synth.triggerAttackRelease(['C4', 'E4', 'G4'], '8n'),\n    wave: () => {\n      window._synth.triggerAttackRelease('C4', '8n', Tone.now());\n      window._synth.triggerAttackRelease('E4', '8n', Tone.now() + 0.1);\n      window._synth.triggerAttackRelease('G4', '8n', Tone.now() + 0.2);\n    },\n    damage: () => window._synth.triggerAttackRelease('C3', '8n'),\n    gameOver: () => {\n      window._synth.triggerAttackRelease(['C3', 'G2', 'C2'], '2n');\n    }\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
  "updateCode": "// Tower Defense Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  // Mouse input handling\n  canvas.onclick = (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const scale = canvas.width / 64;\n    const x = Math.floor((e.clientX - rect.left) / scale);\n    const y = Math.floor((e.clientY - rect.top) / scale);\n\n    // Check if clicking on tower menu\n    if (y >= 58) {\n      const index = Math.floor(x / 20);\n      if (index < state.towerTypes.length) {\n        state.selected = index;\n      }\n      return;\n    }\n\n    // Place tower\n    if (state.selected !== null) {\n      const tower = state.towerTypes[state.selected];\n      if (state.gold >= tower.cost) {\n        // Check if space is clear\n        const isClear = !state.towers.some(t => t.x === x && t.y === y) &&\n                       !state.path.some(p => Math.abs(p.x - x) < 2 && Math.abs(p.y - y) < 2);\n        \n        if (isClear) {\n          state.towers.push({\n            x, y,\n            type: state.selected,\n            cooldown: 0\n          });\n          state.gold -= tower.cost;\n          if (window._effects) window._effects.build();\n        }\n      }\n    }\n  };\n\n  // Wave management\n  if (state.enemiesLeft <= 0 && state.enemies.length === 0) {\n    state.waveTimer--;\n    if (state.waveTimer <= 0) {\n      state.wave++;\n      state.enemiesLeft = state.wave * 5;\n      state.waveTimer = 180;\n      if (window._effects) window._effects.wave();\n    }\n  }\n\n  // Spawn enemies\n  if (state.enemiesLeft > 0 && Math.random() < 0.05) {\n    state.enemies.push({\n      x: state.path[0].x,\n      y: state.path[0].y,\n      health: 50 + state.wave * 10,\n      maxHealth: 50 + state.wave * 10,\n      pathIndex: 0,\n      progress: 0\n    });\n    state.enemiesLeft--;\n  }\n\n  // Update towers\n  state.towers.forEach(tower => {\n    const type = state.towerTypes[tower.type];\n    if (tower.cooldown > 0) {\n      tower.cooldown--;\n    } else {\n      // Find target\n      let target = null;\n      let minDist = type.range;\n      \n      state.enemies.forEach(enemy => {\n        const dist = Math.sqrt(\n          Math.pow(enemy.x - tower.x, 2) +\n          Math.pow(enemy.y - tower.y, 2)\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          target = enemy;\n        }\n      });\n\n      if (target) {\n        state.projectiles.push({\n          x: tower.x,\n          y: tower.y,\n          targetX: target.x,\n          targetY: target.y,\n          damage: type.damage,\n          speed: 2\n        });\n        tower.cooldown = type.rate;\n        if (window._effects) window._effects.shoot();\n      }\n    }\n  });\n\n  // Update projectiles\n  state.projectiles = state.projectiles.filter(proj => {\n    const dx = proj.targetX - proj.x;\n    const dy = proj.targetY - proj.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    \n    if (dist < proj.speed) {\n      // Hit target\n      state.enemies.forEach(enemy => {\n        if (Math.abs(enemy.x - proj.targetX) < 1 &&\n            Math.abs(enemy.y - proj.targetY) < 1) {\n          enemy.health -= proj.damage;\n          if (window._effects) window._effects.hit();\n        }\n      });\n      return false;\n    }\n\n    proj.x += (dx / dist) * proj.speed;\n    proj.y += (dy / dist) * proj.speed;\n    return true;\n  });\n\n  // Update enemies\n  state.enemies = state.enemies.filter(enemy => {\n    if (enemy.health <= 0) {\n      state.gold += 10;\n      return false;\n    }\n\n    const target = state.path[enemy.pathIndex];\n    const dx = target.x - enemy.x;\n    const dy = target.y - enemy.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist < 0.5) {\n      enemy.pathIndex++;\n      if (enemy.pathIndex >= state.path.length) {\n        state.lives--;\n        if (window._effects) window._effects.damage();\n        if (state.lives <= 0) {\n          state.gameOver = true;\n          if (window._effects) window._effects.gameOver();\n        }\n        return false;\n      }\n    } else {\n      enemy.x += (dx / dist) * 0.5;\n      enemy.y += (dy / dist) * 0.5;\n    }\n\n    return true;\n  });\n\n  // Clear screen\n  ctx.fillStyle = '#001100';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const scale = canvas.width / 64;\n\n  // Draw path\n  ctx.strokeStyle = '#333333';\n  ctx.lineWidth = scale * 2;\n  ctx.beginPath();\n  ctx.moveTo(state.path[0].x * scale, state.path[0].y * scale);\n  state.path.forEach(point => {\n    ctx.lineTo(point.x * scale, point.y * scale);\n  });\n  ctx.stroke();\n\n  // Draw towers\n  state.towers.forEach(tower => {\n    const type = state.towerTypes[tower.type];\n    ctx.fillStyle = tower.type === 0 ? '#4444ff' :\n                   tower.type === 1 ? '#ff4444' : '#44ff44';\n    ctx.fillRect(tower.x * scale - scale, \n                 tower.y * scale - scale,\n                 scale * 2,\n                 scale * 2);\n\n    // Draw range\n    if (state.selected !== null && \n        tower.x === Math.floor(canvas.mouseX / scale) &&\n        tower.y === Math.floor(canvas.mouseY / scale)) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.beginPath();\n      ctx.arc(tower.x * scale,\n              tower.y * scale,\n              type.range * scale,\n              0, Math.PI * 2);\n      ctx.stroke();\n    }\n  });\n\n  // Draw enemies\n  state.enemies.forEach(enemy => {\n    // Health bar\n    ctx.fillStyle = '#ff0000';\n    ctx.fillRect(enemy.x * scale - scale,\n                 enemy.y * scale - scale * 1.5,\n                 scale * 2,\n                 scale * 0.3);\n    ctx.fillStyle = '#00ff00';\n    ctx.fillRect(enemy.x * scale - scale,\n                 enemy.y * scale - scale * 1.5,\n                 (enemy.health / enemy.maxHealth) * scale * 2,\n                 scale * 0.3);\n\n    // Enemy body\n    ctx.fillStyle = '#ff0000';\n    ctx.beginPath();\n    ctx.arc(enemy.x * scale,\n            enemy.y * scale,\n            scale,\n            0, Math.PI * 2);\n    ctx.fill();\n  });\n\n  // Draw projectiles\n  ctx.fillStyle = '#ffffff';\n  state.projectiles.forEach(proj => {\n    ctx.beginPath();\n    ctx.arc(proj.x * scale,\n            proj.y * scale,\n            scale * 0.5,\n            0, Math.PI * 2);\n    ctx.fill();\n  });\n\n  // Draw HUD\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '16px monospace';\n  ctx.fillText(`Gold: ${state.gold}  Lives: ${state.lives}  Wave: ${state.wave}`, \n               10, 20);\n\n  if (state.enemiesLeft <= 0 && state.enemies.length === 0) {\n    ctx.fillText(`Next wave in: ${Math.ceil(state.waveTimer / 60)}`, \n                 10, 40);\n  }\n\n  // Draw tower menu\n  ctx.fillStyle = '#333333';\n  ctx.fillRect(0, 58 * scale, canvas.width, 6 * scale);\n\n  state.towerTypes.forEach((type, i) => {\n    ctx.fillStyle = i === 0 ? '#4444ff' :\n                   i === 1 ? '#ff4444' : '#44ff44';\n    ctx.fillRect(i * 20 * scale + scale,\n                 59 * scale,\n                 18 * scale,\n                 4 * scale);\n\n    if (i === state.selected) {\n      ctx.strokeStyle = '#ffffff';\n      ctx.strokeRect(i * 20 * scale + scale,\n                    59 * scale,\n                    18 * scale,\n                    4 * scale);\n    }\n\n    ctx.fillStyle = '#ffffff';\n    ctx.font = '12px monospace';\n    ctx.fillText(`${type.name}`,\n                 i * 20 * scale + scale * 2,\n                 60 * scale);\n    ctx.fillText(`$${type.cost}`,\n                 i * 20 * scale + scale * 2,\n                 62 * scale);\n  });\n\n  // Game over screen\n  if (state.gameOver) {\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    ctx.fillStyle = '#ffffff';\n    ctx.font = '40px monospace';\n    ctx.fillText('Game Over!', canvas.width/4, canvas.height/2);\n    ctx.font = '20px monospace';\n    ctx.fillText(`Survived ${state.wave} waves`, \n                 canvas.width/4, canvas.height/2 + 40);\n  }\n})();",
  "displayMode": "1",
  "timestamp": "2025-11-04T00:00:00.000Z"
}