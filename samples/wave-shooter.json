{
  "initCode": "// Wave Shooter Init\nwindow._state = {\n  player: {\n    x: 32,\n    y: 56,\n    health: 100\n  },\n  bullets: [],\n  enemies: [],\n  wave: 1,\n  waveTimer: 180,\n  score: 0,\n  powerups: [],\n  gameOver: false\n};\n\n// Setup audio\ntry {\n  window._synth = new Tone.Synth().toDestination();\n  window._effects = {\n    shoot: () => window._synth.triggerAttackRelease('E5', '32n'),\n    hit: () => window._synth.triggerAttackRelease('C3', '16n'),\n    powerup: () => window._synth.triggerAttackRelease(['C5', 'E5', 'G5'], '8n'),\n    newWave: () => window._synth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n')\n  };\n} catch (e) { console.warn('Tone unavailable', e); }",
  "updateCode": "// Wave Shooter Update\n(function(){\n  const canvas = document.getElementById('game-canvas');\n  const ctx = window._ctx || canvas.getContext('2d');\n  const state = window._state;\n  if (!state || state.gameOver) return;\n\n  // Input handling\n  document.onkeydown = (e) => {\n    if (state.gameOver) return;\n    switch(e.key) {\n      case 'ArrowLeft': state.player.x = Math.max(0, state.player.x - 2); break;\n      case 'ArrowRight': state.player.x = Math.min(63, state.player.x + 2); break;\n      case ' ':\n        state.bullets.push({\n          x: state.player.x,\n          y: state.player.y - 2,\n          power: 1\n        });\n        if (window._effects) window._effects.shoot();\n        break;\n    }\n  };\n\n  // Wave management\n  state.waveTimer--;\n  if (state.waveTimer <= 0 && state.enemies.length === 0) {\n    state.wave++;\n    state.waveTimer = 180;\n    if (window._effects) window._effects.newWave();\n    \n    // Spawn enemies for new wave\n    for (let i = 0; i < state.wave * 3; i++) {\n      state.enemies.push({\n        x: Math.random() * 64,\n        y: Math.random() * 20,\n        health: state.wave,\n        pattern: Math.floor(Math.random() * 3)\n      });\n    }\n\n    // Spawn powerup\n    if (Math.random() < 0.5) {\n      state.powerups.push({\n        x: Math.random() * 64,\n        y: 0,\n        type: Math.random() < 0.5 ? 'health' : 'power'\n      });\n    }\n  }\n\n  // Update bullets\n  state.bullets = state.bullets.filter(bullet => {\n    bullet.y -= 2;\n    return bullet.y > 0;\n  });\n\n  // Update enemies\n  state.enemies = state.enemies.filter(enemy => {\n    // Enemy movement patterns\n    switch(enemy.pattern) {\n      case 0: // Sine wave\n        enemy.x += Math.sin(Date.now() / 500) * 0.5;\n        enemy.y += 0.2;\n        break;\n      case 1: // Zigzag\n        enemy.x += Math.floor(Date.now() / 1000) % 2 ? 1 : -1;\n        enemy.y += 0.3;\n        break;\n      case 2: // Straight down\n        enemy.y += 0.5;\n        break;\n    }\n\n    // Screen bounds\n    if (enemy.x < 0) enemy.x = 63;\n    if (enemy.x > 63) enemy.x = 0;\n\n    // Bullet collision\n    state.bullets.forEach(bullet => {\n      if (Math.abs(bullet.x - enemy.x) < 2 && \n          Math.abs(bullet.y - enemy.y) < 2) {\n        enemy.health -= bullet.power;\n        bullet.y = -1; // Remove bullet\n        if (window._effects) window._effects.hit();\n      }\n    });\n\n    // Player collision\n    if (Math.abs(enemy.x - state.player.x) < 2 && \n        Math.abs(enemy.y - state.player.y) < 2) {\n      state.player.health -= 20;\n      enemy.health = 0;\n      if (window._effects) window._effects.hit();\n    }\n\n    if (enemy.health <= 0) {\n      state.score += state.wave * 10;\n    }\n\n    return enemy.health > 0 && enemy.y < 64;\n  });\n\n  // Update powerups\n  state.powerups = state.powerups.filter(powerup => {\n    powerup.y += 0.5;\n\n    // Player collision\n    if (Math.abs(powerup.x - state.player.x) < 2 && \n        Math.abs(powerup.y - state.player.y) < 2) {\n      if (powerup.type === 'health') {\n        state.player.health = Math.min(100, state.player.health + 30);\n      } else {\n        state.bullets.forEach(bullet => bullet.power++);\n      }\n      if (window._effects) window._effects.powerup();\n      return false;\n    }\n\n    return powerup.y < 64;\n  });\n\n  // Clear screen\n  ctx.fillStyle = '#000033';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const scale = canvas.width / 64;\n\n  // Draw stars\n  for (let i = 0; i < 50; i++) {\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(\n      Math.sin(Date.now()/1000 + i) * canvas.width,\n      (i * scale + Date.now()/50) % canvas.height,\n      1,\n      1\n    );\n  }\n\n  // Draw bullets\n  state.bullets.forEach(bullet => {\n    ctx.fillStyle = bullet.power > 1 ? '#ff00ff' : '#ffff00';\n    ctx.fillRect(bullet.x * scale - scale/4, \n                 bullet.y * scale, \n                 scale/2, \n                 scale);\n  });\n\n  // Draw enemies\n  state.enemies.forEach(enemy => {\n    ctx.fillStyle = `rgb(${255}, ${100 + (enemy.health * 50)}, ${100 + (enemy.health * 50)})`;\n    ctx.fillRect(enemy.x * scale - scale, \n                 enemy.y * scale - scale, \n                 scale * 2, \n                 scale * 2);\n  });\n\n  // Draw powerups\n  state.powerups.forEach(powerup => {\n    ctx.fillStyle = powerup.type === 'health' ? '#00ff00' : '#ff00ff';\n    ctx.beginPath();\n    ctx.arc(powerup.x * scale, \n            powerup.y * scale, \n            scale, 0, Math.PI * 2);\n    ctx.fill();\n  });\n\n  // Draw player\n  ctx.fillStyle = '#00ffff';\n  ctx.fillRect(state.player.x * scale - scale, \n               state.player.y * scale - scale, \n               scale * 2, \n               scale * 2);\n\n  // Draw HUD\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '12px monospace';\n  ctx.fillText(`Wave: ${state.wave}  Score: ${state.score}`, 10, 20);\n  \n  // Health bar\n  ctx.fillStyle = '#ff0000';\n  ctx.fillRect(10, 30, state.player.health, 10);\n\n  // Game over check\n  if (state.player.health <= 0) {\n    state.gameOver = true;\n    ctx.fillStyle = '#ffffff';\n    ctx.font = '24px monospace';\n    ctx.fillText('Game Over!', canvas.width/4, canvas.height/2);\n    ctx.font = '16px monospace';\n    ctx.fillText(`Final Score: ${state.score}`, canvas.width/4, canvas.height/2 + 30);\n  }\n})();",
  "displayMode": "1",
  "timestamp": "2025-11-04T00:00:00.000Z"
}